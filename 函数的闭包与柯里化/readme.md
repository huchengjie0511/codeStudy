函数的**闭包**和**柯里化**是 JavaScript 函数式编程中的两个重要概念。它们涉及到如何处理函数和变量的作用域，以及如何优雅地分步传递参数。下面我会逐步解释这两个概念。

---

### 1. 闭包（Closure）

**闭包**是指函数“记住”它定义时的词法作用域（即外部函数的变量），即使这个函数在其作用域之外执行。

闭包的核心特点是：**函数可以访问定义它时外部的变量，即使这个函数在其他地方被调用**。

#### 举例：
```javascript
function outer() {
  const outerVar = 'I am from outer scope';
  
  return function inner() {
    console.log(outerVar); // inner 函数能够访问 outer 函数的变量
  };
}

const closureFunction = outer();
closureFunction(); // 输出 'I am from outer scope'
```

在这个例子中，`inner` 函数在 `outer` 函数内部定义，即使 `outer` 函数已经执行完毕并返回了，`inner` 函数依然可以访问 `outer` 中的 `outerVar`。这就是闭包的行为。

- **为什么闭包重要？**
  - 它允许我们创建私有变量，隐藏状态，防止外部访问或修改。
  - 它让函数拥有“记忆”，即函数内部可以保持对外部变量的引用。

---

### 2. 柯里化（Currying）

**柯里化**是将一个接受多个参数的函数，转化为一系列只接收一个参数的函数。**每个函数返回一个新的函数，接受下一个参数，直到所有参数都被提供完毕**。

换句话说，柯里化是一种将**多参数函数**转化为**嵌套的单参数函数**的技术。

#### 举例：
```javascript
function multiply(a, b) {
  return a * b;
}

// 将 multiply 函数柯里化
function curriedMultiply(a) {
  return function(b) {
    return a * b;
  };
}

const multiplyBy2 = curriedMultiply(2);
console.log(multiplyBy2(5)); // 输出 10
```

在这个例子中，`curriedMultiply` 是一个柯里化函数。它分两步接收参数：

1. 第一步接收 `a` 参数，并返回一个新的函数。
2. 第二步，新的函数接收 `b` 参数，最终返回 `a * b` 的结果。

柯里化的好处是，它允许我们部分应用函数的参数。例如，`multiplyBy2` 是一个函数，已经固定了第一个参数 `2`，只需要传入第二个参数 `b`。

#### 为什么使用柯里化？

- **代码复用**：通过柯里化，可以很容易地创建带有默认参数的函数，例如 `multiplyBy2` 就是一个已经固定了第一个参数的函数。
- **延迟计算**：柯里化使得我们可以延迟计算，直到所有参数都被提供完毕。
- **函数组合**：在函数式编程中，柯里化使得我们可以更轻松地将多个函数组合起来。

#### 更复杂的柯里化例子：
```javascript
function curriedSum(a) {
  return function(b) {
    return function(c) {
      return a + b + c;
    };
  };
}

console.log(curriedSum(1)(2)(3)); // 输出 6
```

上面的 `curriedSum` 是一个三参数的柯里化函数，它接收一个参数 `a`，返回一个函数，再接收一个参数 `b`，再返回一个函数，最终接收 `c` 参数并计算 `a + b + c`。

---

### 闭包与柯里化的区别与联系：

- **闭包**：指的是函数记住了它定义时的作用域，并在执行时可以访问外部作用域的变量。
- **柯里化**：是将一个多参数函数分解成一系列单参数函数的过程。

柯里化通常依赖于闭包，因为每次返回的嵌套函数都“记住”了前面传入的参数。例如，在柯里化过程中，每个函数会“闭包”捕获之前的参数，直到最后一个函数被调用时，所有的参数才会被使用。

---

### 总结：

- **闭包** 使函数能够记住并访问外部函数的变量，即使这个函数在外部作用域调用。
- **柯里化** 是将一个多参数函数转换成一系列单参数函数的技术，有助于分步传递参数。

两者都是非常强大的工具，广泛应用于 JavaScript 的函数式编程中。